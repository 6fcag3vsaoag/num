import numpy as np
# 0.61 0.71 -0.05
# -1.03 -2.05 0.87 
# 2.5 -3.12 -5.03

# 0.44 -1.16 -7.5 

A = []
print('Введите коэффициенты матрицы (введите "стоп" для завершения ввода):')
while True:
    row = input()  # Считываем строку ввода
    if row.lower() == 'стоп':  # Проверяем, введено ли слово "стоп" для завершения ввода
        break
    A.append(list(map(float, row.split())))  # Преобразуем строку в список чисел и добавляем в матрицу A

# Ввод коэффициентов вектора b
print('Введите свободные члены через пробел:')
b = list(map(float, input().split()))  # Преобразуем строку в список чисел

# Преобразуем списки в numpy массивы
A = np.array(A)
b = np.array(b)

# Применяем перестановки для улучшения сходимости
if abs(A[0][0]) <= abs(A[1][0]):
    A[[0, 1]] = A[[1, 0]]  # Меняем местами строки 0 и 1, если элемент в [0, 0] меньше или равен элементу в [1, 0]
    b[[0, 1]] = b[[1, 0]]  # Меняем местами соответствующие элементы в векторе b
if abs(A[0][0]) <= abs(A[2][0]):
    A[[0, 2]] = A[[2, 0]]  # Меняем местами строки 0 и 2, если элемент в [0, 0] меньше или равен элементу в [2, 0]
    b[[0, 2]] = b[[2, 0]]  # Меняем местами соответствующие элементы в векторе b
if abs(A[1][1]) <= abs(A[0][1]):
    A[[1, 0]] = A[[0, 1]]  # Меняем местами строки 1 и 0, если элемент в [1, 1] меньше или равен элементу в [0, 1]
    b[[1, 0]] = b[[0, 1]]  # Меняем местами соответствующие элементы в векторе b
if abs(A[1][1]) <= abs(A[2][1]):
    A[[1, 2]] = A[[2, 1]]  # Меняем местами строки 1 и 2, если элемент в [1, 1] меньше или равен элементу в [2, 1]
    b[[1, 2]] = b[[2, 1]]  # Меняем местами соответствующие элементы в векторе b
if abs(A[2][2]) <= abs(A[1][2]):
    A[[2, 1]] = A[[1, 2]]  # Меняем местами строки 2 и 1, если элемент в [2, 2] меньше или равен элементу в [1, 2]
    b[[2, 1]] = b[[1, 2]]  # Меняем местами соответствующие элементы в векторе b
if abs(A[2][2]) <= abs(A[0][2]):
    A[[2, 0]] = A[[0, 2]]  # Меняем местами строки 2 и 0, если элемент в [2, 2] меньше или равен элементу в [0, 2]
    b[[2, 0]] = b[[0, 2]]  # Меняем местами соответствующие элементы в векторе b

#print(A, b)

# Решаем СЛАУ, используя метод Зейделя

def Zeidel(A, B, tol=1e-4, max_iterations=100): #tol=1e-4 - параметр точности,который определяет насколько близкими должны быть значения вектора решения на текущей и предыдущей итерациях, чтобы алгоритм остановился. max_iterations - максимальное количество итераций
    n = A.shape[0]  # Определяем размерность матрицы A
    x = np.zeros(n)  # Инициализируем вектор решения нулями
    
    for iteration in range(max_iterations):  # Итерационный процесс
        x_new = np.copy(x)  # Создаем копию текущего вектора решения
        for i in range(n):
            s1 = np.dot(A[i, :i], x_new[:i])  # Сумма произведений элементов строки на новые значения x до i
            s2 = np.dot(A[i, i + 1:], x[i + 1:])  # Сумма произведений элементов строки на старые значения x после i
            x_new[i] = (B[i] - s1 - s2) / A[i, i]  # Вычисляем новое значение x[i]
        if np.allclose(x, x_new, rtol=tol):  # Проверяем условие сходимости
            break  # Если условие выполнено, выходим из цикла
        x = x_new  # Обновляем вектор x
    
    return x  # Возвращаем найденное решение


# Выводим решение 
X = Zeidel(A, b)

print('Решение СЛАУ:')
for i in range(len(X)):
    print(f'x_{i+1} = {X[i]}')
